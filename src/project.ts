import chalk = require("chalk");
import path = require("path");
import * as fs from "fs";
import * as semver from "semver";
import * as validatePackageName from "validate-npm-package-name";
import { getParsedTargetJson, rollback } from "./utils";
import { exec } from "node:child_process";
import * as prettier from "prettier";
import { ProcessExecResponse } from "./types/ProcessExecResponse";
import { WebpackConfigBuilder } from "./types/WebpackConfigBuilder";

export function Project() {
  //#region Properties
  let projectName: string;
  let projectDir: string;
  let template: string = "es6-template";
  let version: string = "1.0.0";
  let options: string[] = [];
  //#endregion

  //#region Closure to create the project

  /**
   * Creates a working webpack project.
   * - Installs the template. Required webpack config builder file is built in this step by running the template script.
   * - Reads the required webpack configuration builder generated by the template and writes into webpack.config.js in the target project folder accordingly.
   * - Copies everything inside the template subdirectory of the template into the target project folder.
   * - Installs all the dependencies in the target project folder.
   *
   * Project creation is then marked complete.
   * @returns
   */
  const makeProject = async () => {
    // Search NPM repo for the template initialized by the tool, install the template locally and proceed.
    // Since this is a prototype, template loading is hard-coded.
    // Everything is simplistically coded. Can be optimized further.
    const templateRootDir = path.resolve("es6-template");
    const templateDir = path.join(templateRootDir, "template");
    // install the template - install template dependencies and execute the script. Project dependencies may change here. A webpack config guide is generated.
    const templateInstallationResult = await installTemplate(templateRootDir);
    if (!templateInstallationResult.success) {
      return false;
    }
    const builtProjectWpConfig =
      await buildProjectWebpackConfig(templateRootDir); // build the webpack config using the config guide.
    if (!builtProjectWpConfig.success) {
      return false;
    }
    const targetPackageJsonWritten =
      await writeTemplateTargetPackageJson(templateRootDir); // write the final dependencies into the package.json located in the root of the project output.
    if (!targetPackageJsonWritten.success) {
      return false;
    }
    const templateDataCopied = await copyTemplatedData(templateDir); // copy the templated data to be copied as is.
    if (!templateDataCopied.success) {
      return false;
    }
    const depsInstallationResult = await installProjectDeps(); // install project dependencies.
    return depsInstallationResult.success;
  };

  /**
   * Installs a template using the following steps:
   * - Installs all the dependencies of the template in the template directory for the template script to run properly.
   * - Runs the template script by passing all the config options to it, to get the configured webpack.config.
   * Template installation is marked as complete upon the successful conclusion of all the mentioned steps.
   * @param templateDir Directory where the template is located in.
   * @returns
   */
  const installTemplate = (
    templateRootDir: string | URL
  ): Promise<ProcessExecResponse> => {
    const templateInstallFailedMessage =
      "Unable to install the template. Please check your internet connection.";
    return new Promise((resolve) => {
      // install template deps
      const templateNpmInstall = exec(
        "npm install --save --loglevel error",
        { cwd: templateRootDir },
        (error, stdout, stderr) => {
          if (error) {
            rollback(
              templateRootDir.toString(),
              resolve,
              templateInstallFailedMessage
            );
          }
          if (stdout) {
            console.log(stdout);
          }
          if (stderr) {
            console.error(stderr);
          }
        }
      );

      templateNpmInstall.on("close", async (code) => {
        if (code !== 0) {
          rollback(
            templateRootDir.toString(),
            resolve,
            templateInstallFailedMessage
          );
          return;
        }
        console.log("Installed template dependencies");
        console.log("Installing the template...");
        resolve(await runTemplateScript(templateRootDir));
      });
    });
  };

  const runTemplateScript = (
    templateRootDir: string | URL
  ): Promise<ProcessExecResponse> => {
    const templateScriptError =
      "Error occurred when trying to build template, likely due to a bug in template builder. Please check with the template authors.";
    return new Promise((resolve) => {
      const templateScriptProcess = exec(
        `node script.js --options ${options.join(" ")}`,
        { cwd: templateRootDir },
        (error, stdout, stderr) => {
          if (error) {
            rollback(templateRootDir.toString(), resolve, templateScriptError);
          }
          if (stdout) {
            console.log(stdout);
          }
          if (stderr) {
            console.error(stderr);
          }
        }
      );
      templateScriptProcess.on("close", (code) => {
        if (code === 0) {
          console.log(
            chalk.green("Configured webpack as per options provided.")
          );
          resolve({ success: true });
          return;
        }
        rollback(templateRootDir.toString(), resolve, templateScriptError);
      });
    });
  };

  const buildProjectWebpackConfig = (
    templateRootDir: string
  ): Promise<ProcessExecResponse> => {
    return new Promise((resolve) => {
      const configHelper: WebpackConfigBuilder = JSON.parse(
        fs
          .readFileSync(
            path.resolve(templateRootDir, "webpack.config.helper.json")
          )
          .toString()
      );
      const { requires, config } = configHelper;
      /**
       * Config string to be written into the webpack.config.js file in the output project directory.
       */
      let configOut = "";
      for (const [variableName, packageName] of Object.entries(requires)) {
        configOut += `const ${variableName} = require("${packageName}");\n`;
      }
      configOut += `const isProduction = process.env.NODE_ENV == 'production';\n`;
      configOut += `const config = ${JSON.stringify(config)
        .replace(/\\/g, "")
        .replace(/"\$code\{(.*?)\}"/g, "$1")};\n`;
      configOut += `module.exports = () => {
            if (isProduction) {
                config.mode = 'production';
                
                
            } else {
                config.mode = 'development';
            }
            return config;
        };`;
      prettier
        .format(configOut, { parser: "babel" })
        .then((prettifiedConfig) => {
          try {
            fs.writeFileSync(
              path.resolve(projectDir, "webpack.config.js"),
              prettifiedConfig
            );
            resolve({ success: true });
          } catch (error) {
            rollback(projectDir, resolve);
          }
        });
      // .catch((err) => {
      //   rollback(projectDir, resolve);
      // });
    });
  };

  /**
   * Function to copy templated files to the output folder.
   * @param templateDir Dir of the template data to be copied as is to the output directory.
   */
  const copyTemplatedData = (
    templateDir: string | URL
  ): Promise<ProcessExecResponse> => {
    return new Promise((resolve) => {
      fs.cp(templateDir, projectDir, { recursive: true }, (err) => {
        if (err) {
          rollback(
            projectDir,
            resolve,
            "Error occurred when installing the template. Rolling back changes."
          );
          return;
        }
        console.log(chalk.greenBright("Project files initialized."));
        resolve({ success: true });
      });
    });
  };

  const writeTemplateTargetPackageJson = async (
    templateRoot: string
  ): Promise<ProcessExecResponse> => {
    const targetPackageJson = getParsedTargetJson(
      path.resolve(templateRoot, "target_package.json")
    );
    targetPackageJson.version = version;
    targetPackageJson.name = projectName;
    try {
      // verify validity of template dependencies in the final project.
      const formattedPkgJson = await prettier.format(
        JSON.stringify(targetPackageJson),
        { parser: "json" }
      );
      fs.writeFileSync(
        path.resolve(projectDir, "package.json"),
        formattedPkgJson
      );
      return { success: true };
    } catch (error) {
      return { success: false };
    }
  };

  const installProjectDeps = (): Promise<ProcessExecResponse> => {
    return new Promise((resolve) => {
      const depInstallFailedMessage =
        "Installing dependencies failed. Rolling back changes...";
      const purple = chalk.hex("#8e44ad");
      console.log(purple("Installing dependencies..."));
      const child = exec(
        "npm install --save --loglevel error",
        {
          cwd: projectDir,
        },
        (error, stdout, stderr) => {
          if (error) {
            rollback(projectDir, resolve, depInstallFailedMessage);
          }
          if (stdout) {
            console.log(stdout);
          }
          if (stderr) {
            console.error(stderr);
          }
        }
      );
      child.on("close", (code) => {
        if (code === 0) {
          console.log(chalk.green("Installed all dependencies"));
          resolve({ success: true });
          return;
        }
        rollback(projectDir, resolve, depInstallFailedMessage);
      });
    });
  };

  //#endregion

  //#region property setters
  /**
   * Sets the name of the target project.
   * @param dir Project Directory of the target project
   */
  makeProject.projectDirectory = (dir: string) => {
    if (!dir) {
      console.error(chalk.red("Project directory must be specified."));
      process.exit(1);
    }
    const root = path.resolve(dir);
    const packageName = path.basename(root);
    const validation = validatePackageName(packageName);
    if (!validation.validForNewPackages) {
      console.error(
        chalk.red(
          "Name specified for the project is incompatible with NPM naming scheme. Choose a different name."
        )
      );
      process.exit(1);
    }
    if (!fs.existsSync(root)) {
      fs.mkdirSync(root);
    }
    // check if a project already exists in the target directory. Leaving the part out since this is only a prototype.
    projectDir = dir;
    projectName = packageName;
  };

  /**
   * Sets all the options which will be passed to template script.
   * @param opts Array of options passed to configure the output.
   */
  makeProject.options = (opts?: string[]) => {
    if (!opts) {
      return;
    }
    options = opts;
    console.log("Configuration stored.");
  };

  makeProject.template = (templateName?: string) => {
    template = templateName || template || "es6-template";
  };

  makeProject.version = (projectVersion?: string) => {
    if (!version) {
      return;
    }
    if (!semver.valid(projectVersion)) {
      console.warn(
        chalk.yellow(
          "Invalid version specified. Defaulting the version to 1.0.0. You may change the version in the package.json file."
        )
      );
      return;
    }
    version = projectVersion;
  };

  //#endregion

  return makeProject;
}
